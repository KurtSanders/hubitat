/**
*   simple sendmail  .. lg kahn kahn@lgk.com
*  You should have received a copy of the GNU General Public License
*  along with this program.  If not, see <https://www.gnu.org/licenses/>.
* 
* v 2.1 added desciprtive text and cleaned up debugging
* v 2.2 added hostname option and lookup ip if blank.
* v 2.3 added better checking for end of send to make sure it is closing cleanly
* v 2.4 add serial queueing so that a new connect waits while old finishes.. set timeout to 1 minute to wait. if email is not finished by
*       then close connection and start new one. Also add state.lastCommand to follow the attribute as that seems more reliable.
* v 2.4.1 ignore stream is closed errors in telnetStatus fx as the is a system callback and is not working correctly , intermittantly i get a call
*       to this function telling me socket is closed but it obviously is not because responses are still asynchronously coming basck after!
*      This "Stream is closed" messages seems to always come out after the quit command so it appears to be a status message not really an error
*
*/


attribute "lastCommand", "string"
attribute "myHostName", "string"

preferences {
	input("EmailServer", "text", title: "Email Server:", description: "Enter location of email server", required: true)
	input("EmailPort", "integer", title: "Port #:", description: "Enter port number, default 25", defaultValue: 25)
	input("From", "text", title: "From:", description: "", required: true)
	input("To", "text", title: "To:", description: "", required: true)
	input("Subject", "text", title: "Subject:", description: "")
    input("myHostName", "text", title: "Your host name:", description: "Fully qualified domain/hostname (FQDN) to use in initial HELO/EHELO command. If blank you ip address will be used?", requierd: false)
    input("debug", "bool", title: "Enable logging?", required: true, defaultValue: false)
    input("Authenticate", "bool", title: "Use Authentication on the server?", required: false, defaultValue: false)
    input("Username", "text", title: "Username for Authentication - (base64 encoded)?", required: false, defaultValue: "")
    input("Password", "text", title: "Password for Authentication - (base64 encoded)?", required: false, defaultValue: "")
}

metadata {
    definition (name: "LGK Sendmail V2", namespace: "lgkapps", author: "larry kahn kahn@lgk.com") {
    capability "Notification"
    capability "Actuator"
	capability "Telnet"
	capability "Configuration"
    }
}

def installed() {
    initialize()
}

def updated() {
    initialize()   
}

def configure()
{
    initialize()
}


def initialize() {

    state.lastMsg = ""
	state.LastCode = 0
	state.EmailBody = ""
    state.lastCommand = "quit"
    
    if ((!myHostName) || (myHostName == ""))
    {
        log.debug "User specified hostname is blank using IP instead."
        def hub = location.hubs[0]
	    def myName =  "[" + hub.getDataValue("localIP") + "]"
    
        state.myHostName = myName
        sendEvent(name: "myHostName", value: myName)
    }
    
    else
    {
        state.myHostName = myHostName
        sendEvent(name: "myHostName", value: myHostName)  
    }
    
    
}

def runAgain(String message)
{
    def oldState = state.lastCommand
    if (debug) log.debug "Staring up... Initial state found: ($oldState)"
    
    if (!((oldState == "Sent Ok") || (oldState == "Send Failed") || (oldState == "Connection Closed") || (oldState == "quit") || (oldState == "Force Closed")) ) 
      { 
       log.debug "Existing State still ($oldstate)... Last message appears to have failed. Force closing existing connection and sending new message."
       closeConnection()
       state.lastCommand = "Force Closed" 
       sendEvent(name: "lastCommand", value: "Force Closed")
      }
    
     deviceNotification(message)   
}

def deviceNotification(String message) {

def version = "2.4.1"
def Boolean goOn = true

if (state.lastCommand == null)
    {
        state.lastCommand = "quit"
    }
    
if (debug) log.debug "-------> In lgk sendmail Version ($version)"
    
    // lgk now check if we are already in middle of a message and if so wait for a minute.. if after that we still are force close the connection and resume this
    // message
    
    def oldState = state.lastCommand
    
    if (debug) log.debug "Initial state found: ($oldState)"
    
    if (!((oldState == "Sent Ok") || (oldState == "Send Failed") || (oldState == "Connection Closed") || (oldState == "quit") || (oldState == "Force Closed")))   
      { 
            goOn = false
            log.debug "Existing state ($oldState) indicates last run did not complete. Waiting 1 minute then trying again!"
            runIn(60,"runAgain",[data: [message]])
         }

  
       if (goOn)
        {
          if (debug) log.debug "Found ok initial state... going on!"
        
           state.lastCommand = "initialConnect"
           sendEvent(name: "lastCommand", value: "initialConnect")
    
	       state.EmailBody = "${message}"
	       state.LastCode = 0
        
           if (debug) log.debug "Connecting to ${EmailServer}:${EmailPort}"
	
	       //telnetClose()
	       telnetConnect(EmailServer, EmailPort.toInteger(), null, null)  
        }
}


def sendData(String msg, Integer millsec) {
 if (debug) log.debug "$msg"
	
	def hubCmd = sendHubCommand(new hubitat.device.HubAction("${msg}", hubitat.device.Protocol.TELNET))
	pauseExecution(millsec)
	
	return hubCmd
}

def parse(String msg) {
	 
    //def lastCommand = device.currentValue("lastCommand")
    def lastCommand = state.lastCommand
    
    if (debug) {
        log.debug "In parse - ${msg}"
        log.debug "lastCommand = $lastCommand"
    }
        
    
    def pair = msg.split(" ")

     def response = pair[0]
     def value = pair[1]
    
   if (debug) log.debug "Got server response $response value = $value lastCommand = ($lastCommand)"
    
 
   if (lastCommand == "initialConnect")
        {
         if (debug)    log.debug "In initialConnect case"
             if (response == "220")
                 {
                     state.lastCommand = "helo"
                     sendEvent(name: "lastCommand", value: "helo") 
                     def res1 = sendData("helo $state.myHostName",500)
                 }
                 else
                 {
                    closeOnError()
                 }
                }
    
   else if (lastCommand == "Auth")
    {
     if (debug) log.debug "In auth response looking for 334"
     if (response == "334")
     {
       if (debug) log.debug "Got auth response now sending username"
 
        state.lastCommand = "Username"
        sendEvent(name: "lastCommand", value: "Username")
 
        def res1 = sendData("$Username",500)
     }
    else  
    {
         log.debug "Got bad response for auth = $response"
         state.lastCommand = "Send Failed"
         sendEvent(name: "lastCommand", value: "Send Failed")  
         closeConnection()
     }
    }   

   else if (lastCommand == "Username")
    {
     if (debug) log.debug "In Username response looking for 334"
     if (response == "334")
     {
       if (debug) log.debug "Got username response now sending password"
       state.lastCommand = "Password"
       sendEvent(name: "lastCommand", value: "Password")
       def res1 = sendData("$Password",500)
     }
    else  
    {
         log.debug "Got bad response for Username = $response"
         state.lastCommand = "Send Failed"
         sendEvent(name: "lastCommand", value: "Send Failed")  
         closeConnection()
     }
    }   
     
    else if ((lastCommand == "helo") || (lastCommand == "Password"))
        {
        if (debug) log.debug "In helo/Password case"
        if ((response == "250") || (response == "235"))
         {
        
          if ((lastCommand == "helo") && (Authenticate) && (Username) && (Password))
          {
           if (debug) log.debug "Trying authentication"
              
           state.lastCommand = "Auth"
           sendEvent(name: "lastCommand", value: "Auth")
           def res1 = sendData("auth login",500)
          }

         else
           {
           if (debug) "Either got 250 for helo or 235 for password, Now Sending Message"
               
            state.lastCommand = "sendmessage"
            sendEvent(name: "lastCommand", value: "sendmessage") 
                    
            def msgData = "${state.EmailBody}"
	        def emlBody = ""
	        def emlSubject = ""
	        def emlDateTime = new Date()
	
	        if(msgData.substring(0,1) == "{") {
	             	
		        def slurper = new groovy.json.JsonSlurper()
		        def result = slurper.parseText(msgData)
		        emlBody = result.Body
		        emlSubject = (result.Subject != null ? result.Subject : "")
	        } else {
	           	emlBody = msgData
	        	emlSubject = (Subject != null ? "${Subject}" : "")
	        }
   
           
               
	        def sndMsg =[
	        		"MAIL FROM: ${From}"
	        		, "RCPT TO: ${To}"
	        		, "DATA"
	        		, "From: ${From}"
	        		, "To: ${To}"
	        		, "Subject: ${emlSubject}"
	        		, "Date: ${emlDateTime}"		
            		, ""
	        		, "${emlBody}"
            		, ""
	        		, "."
		        	, "quit"
	            ]  
                 
                 def res1 = seqSend(sndMsg,500)             
         }
         }
         else
         {
             closeOnError()
         }
        }
    
    else if (lastComamnd == "sendmessage")
        {
       if (debug) log.debug "In send message case"
             if (response == "220")
                 {
                     log.debug "sending quit"
                     state.lastCommand = "quit"
                     sendEvent(name: "lastCommand", value: "quit")     
                     def res1 = sendData("quit",500)
                 }
                 else
                 {
                    closeOnError()
                 }
                }
       else if ((lastComamnd == "quit") || (response == "221"))
                //&& ((value == "bye") || (value == "2.0.0"))))
        {
          if (debug) log.debug "In quit case"
               if (response == "220" || response == "221")
                 { 
                   state.lastCommand = "Sent Ok"
                   sendEvent(name: "lastCommand", value: "Sent Ok")      
                   closeConnection()
                 }
                 else
                 {
                      closeOnError()
                 }
           } 
        else 
        {
            if (response == "250" || response == "354" || response == "221")
            {
                state.lastCommand = "other"
                sendEvent(name: "lastCommand", value: "other")
            }
            else
            {
                log.debug "response = "
                log.debug "$resonse"
                log.debug "*************"
                closeOnError()
            }
        }         
                  
 
  
}

def telnetStatus(status) {
    // comment out telent status as it is not working correctly and the system is telling me the socket is closed and other
    // response are still returned on the socket after. ignore stream is closed errors.
    if (status != "receive error: Stream is closed") 
    {    
        if (debug) log.debug "telnetStatus: ${status} lastcommand is ($state.lastCommand)"
        sendEvent([name: "telnet", value: "${status}"])
    }
}


def closeConnection()
{
    if (closeTelnet){
                try {
                    telnetClose()
                    state.lastCommand = "Connection Closed"
                    sendEvent(name: "lastCommand", value: "Connection Closed")
                } catch(e) {
                    if (debug) log.debug("Connection Closed")
                }
                
			}
}
    
boolean seqSend(msgs, Integer millisec)
{
    if (debug) log.debug "in sendData"
  
			msgs.each {
				sendData("${it}",millisec)
			}
			seqSent = true
	return seqSent
}

def closeOnError()
{
     log.debug "Got bad response = $response"
     state.lastCommand = "Send Failed"
     sendEvent(name: "lastCommand", value: "Send Failed")  
     closeConnection()    
}
